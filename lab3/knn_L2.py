# -*- coding: utf-8 -*-
"""knn_L2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WBSZ81-DaKYoSRnAhTRgINWWWMRDXl-Q

#L2 (Euclidean) distance
"""

import numpy as np

class NearestNeighbor:

  def __init__(self):
    pass

  def train(self,X,y):
    self.Xtr = X
    self.ytr = y

  def predict(self,X):
    num_test = X.shape[0]
    Ypred = np.zeros(num_test, dtype = self.ytr.dtype)

    k = int(input("Input k value(odd) : ")) # 임의의 k를 입력받을 수 있도록 코드 추가

    for i in range(num_test):
      distances = np.sum(np.power((self.Xtr - X[i,:]),2), axis = 1)
      distances = np.sqrt(distances)
      sorted_idx = np.argsort(distances)  # 오름차순 정렬
      k_sorted_idx = sorted_idx[:k]    # 작은 순으로 k개 선택
      closest_y = self.ytr[k_sorted_idx]
      cnt_closest_y = np.bincount(closest_y)  # 빈도 수를 count함.
      Ypred[i] = np.argmax(cnt_closest_y) # 빈도수가 가장 많은 value를 Ypred에 담음.

    return Ypred